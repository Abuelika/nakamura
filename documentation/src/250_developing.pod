=head1 Developing

=head2 Using git

Developing the next generation sakai will rely heavily on the use of git
(http://git-scm.com/). Git is a free and open source, distributed version
control system designed to handle everything from small to very large projects
with speed and efficiency. A useful introduction is available via the Git
Community Book (http://book.git-scm.com).

On some systems, git installation may be as simple as:

$ apt-get install git-core

=head2 github

To assist in developing the next generation sakai, you will need at least one
of the free (300MB quota) accounts on github (http://github.com), where next
generation sakai development is currently taking place. Once signed up, you'll
want to configure git to know your user name and email:

$ git config --global user.name "your name"
$ git config --global user.email email@address.com

You then need to set up an ssh key and paste the public key into github.
Details can be found here: http://github.com/guides/providing-your-ssh-key. You
can test whether you have it working by doing:

ssh git@github.com

Note: the test is to git@ and not your username@!

=head2 Forking

Once you have git configured to work with github, you are ready to fork the
next generation sakai code. Log in and go to:

http://github.com/ieb/open-experiments/tree/master

where you will be able to click to fork. This gives you then your own fork of
the project. If you go to your account page and click through to the fork, you
will find a public clone URL, which you can git clone to your local machine and
alter to your hearts content. Once happy, you can commit your clone changes, e.g.:

$ git commit -a

$ git push

Then either verbally contact the development lead to do a pull, or issue a pull
request through the github interface. Subject to code review your changes will
then be in!

=head2 Following forks

If you want to track changes from the open-experiments fork then add it as a
remote source in git:

$ git remote add ieb git://github.com/ieb/open-experiments.git

And use pull to merge changes across:

$ git pull ieb master

Alternatively, if you don't want to automatically merge, you can fetch, review
then merge:

$ git fetch ieb

$ git merge ieb/master

=head2 Fetching other forks

To fetch unmerged features from forks other than ieb master, such as those
listed in the graph at http://github.com/ieb/open-experiments/network, you need
to add the fork as a git checkout remote. First navigate to the repo github
page and copy the clone url.

In your git checkout run 'remote add <name> <clone url>'

Now you can do 'git fetch <name>'

and 'git checkout -b <branchname> <name>/master' allowing you to mix and match
features from various repos.

=head2 git pre-commit hook

There exists a very slightly modified version of the default git pre-commit
hook at
http://sakai-kernel.googlegroups.com/web/pre-commit?gsc=zuchPAsAAABUDOR4v2gX6zt2Ox_oS8Nr,
designed to prevent checking in code with obvious whitespace problems,
additionally reporting files and line numbers for the problems.  Place the file
in your .git/hooks/ directory at the checkout top level and ensure it is
executable.

=head2 git on windows

On windows, it seems that using git through a firewall is not necessarily easy.
There are supposed to be ways to get git to work through a proxy but you may
find some authenticating proxies won't play ball!

You may also find that you can't git pull with the latest msysGit portable
install: PortableGit-1.6.2.2-preview20090408, it seems to be missing a git-pull
binary. Try downloading Git-1.5.5-preview20080413 which should work fine apart
from the firewall issue above.

=head2 Developing with OSGi

OSGi essentially makes Java code modular and handles dependency isolation. This
is achieved via some pretty complex classloader graphing. An OSGi code chunk is
called a module and a system typically comprises many modules. OSGi also
completely manages the lifecycle of the bundles in the system. The modular
nature of OSGi means services could go away at any time or may not be started
when your bundle is starting. OSGi provides listeners and trackers in a
practice called the Whiteboard pattern to handle this behaviour.

See

 http://aaronz-sakai.blogspot.com/2009/04/developing-with-osgi-and-apache-sling.html

for some helpful information.

Whereas in standard Java everything in a JAR is completely visible to all other
JARs, OSGi hides everything in a JAR unless explicitly exported. A bundle that
wants to use another JAR must explicitly import the parts it needs. By default,
there is no sharing. Modules are the OSGi layer that defines how a bundle can
import and export code. Inside OSGi code chunks or modules there exist packages
which can be used:

=over

=item internally (private),

=item exported so others can use them (allowing service dependency sharing),

=item imported (allowing bundles to get dependencies required for external services).

=back

Bundles define an activator (implementing BundleActivator -
http://www.osgi.org/javadoc/r4v41/org/osgi/framework/BundleActivator.html)
which allows developer control over startup and shutdown actions and
registering services. Hence, bundle code should be written to expect a service
might not be ready to use when it is starting. Waiting for services to be
available is bad, because OSGi activators are expected to be quick and delaying
them will cause failures. The solution is to use the OSGi provided listeners
and trackers in a practice called the Whiteboard Pattern. The following links
are a good introduction and you may want to be familiar with the whiteboard
pattern concept before attempting to create your first real bundle:

 http://www.theserverside.com/tt/articles/article.tss?l=WhiteboardForOSGi
 http://www.knopflerfish.org/osgi_service_tutorial.html

=head3 Building and deploying a simple bundle

In the following example, the maven-bundle-plugin is used to build and deploy a
simple bundle. Further information about the plugin is available here:

 http://felix.apache.org/site/apache-felix-maven-bundle-plugin-bnd.html
 http://felix.apache.org/site/apache-felix-bundle-plugin-faq.html
 http://aqute.biz/Code/Bnd

The steps are as follows:

=over

=item Checkout the sample bundle code:

 svn co https://source.sakaiproject.org/contrib/caret/osgi-sample/tags/sample-1.1/ osgi-sample

=item Build the bundle using maven 2:

 cd osgi-sample
 mvn clean install

=item Access the Felix console for bundles (included in Sling):

 http://localhost:8080/system/console/bundles

=item Browse and select the bundle (target/sample-1.1.jar)

=item Click Install or Update and then Refresh Packages

=item Scroll down to the Sample OSGi Bundle If it is listed then you have a properly installed bundle!
					
=item Click the Start and Stop buttons to the bundle's right. You should see in the logs something like:

 Sample starting at: Mon Apr 13 13:15:27 BST 2009
 Sample stopping at: Mon Apr 13 13:15:29 BST 2009

=item Now click Start to make sure the bundle is running

=item Restart Sling (use the admin console or just kill it and rerun)

=item The bundle should be running (started automatically) and "Sample starting..." should appear in the logs.

Here is the (very) simple code from the activator class (comments removed). It
just prints out a message when the bundle starts and another when it stops.

  import java.util.Date;
  import org.osgi.framework.BundleActivator;
  import org.osgi.framework.BundleContext;
  
  public class SampleActivator implements BundleActivator {
    public void start(BundleContext context) throws Exception {
      System.out.println("Sample starting at: " + new Date());
    }
  
    public void stop(BundleContext context) throws Exception {
      System.out.println("Sample stopping at: " + new Date());
    }
  }
  
Congratulations! You have installed your first bundle!
